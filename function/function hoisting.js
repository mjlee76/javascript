/*
2. 함수 호이스팅

3가지의 함수 정의 방식을 알아보았다. 
정의 방식은 달라도 결국 Function 생성자 함수를 통해 함수를 생성하는 것까지 확인하였다. 
그런데 이 3가지 함수 정의 방식은 동작 방식에 약간의 차이가 있다.
*/

var res = square(5);

function square(number) {
    return number * number;
}

/*
위 코드를 보면 함수 선언문으로 함수가 정의되기 이전에 함수 호출이 가능하다. 
함수 선언문의 경우, 함수 선언의 위치와는 상관없이 코드 내 어느 곳에서든지 호출이 가능한데 
이것을 함수 호이스팅(Function Hoisting)이라 한다.

자바스크립트는 ES6의 let, const를 포함하여 
모든 선언(var, let, const, function, function*, class)을 
호이스팅(Hoisting)한다.

호이스팅이란 var 선언문이나 function 선언문 등 모든 선언문이 
해당 Scope의 선두로 옮겨진 것처럼 동작하는 특성을 말한다.

즉, 자바스크립트는 모든 선언문 (var, let, const, function, function*, class)이 
선언되기 이전에 참조 가능하다.

함수 선언문으로 정의된 함수는 자바스크립트 엔진이 스크립트가 로딩되는 시점에 
바로 초기화하고 이를 VO(variable object)에 저장한다. 
즉, 함수 선언, 초기화, 할당이 한번에 이루어진다. 
그렇기 때문에 함수 선언의 위치와는 상관없이 소스 내 어느 곳에서든지 호출이 가능하다.
*/

var res = sqaure(5); // TypeError: sqaure is not a function

var square = function(number) {
    return number * number;
}

/*
함수 선언문의 경우와는 달리 TypeError가 발생하였다. 
함수 표현식의 경우 함수 호이스팅이 아니라 변수 호이스팅이 발생한다.

변수 호이스팅은 변수 생성 및 초기화와 할당이 분리되어 진행된다. 
호이스팅된 변수는 undefined로 초기화 되고 실제값의 할당은 할당문에서 이루어진다.

@@@@@@@
자바스크립트의 권위자인 더글러스 크락포드(Douglas Crockford)는 
이와 같은 문제 때문에 함수 표현식만을 사용할 것을 권고하고 있다. 
함수 호이스팅이 함수 호출 전 반드시 함수를 선언하여야 한다는 규칙을 무시하므로 
코드의 구조를 엉성하게 만들 수 있다고 지적한다.

=> 함수 선언문을 사용하는 경우는 공통된 모듈등에만 보통 사용한다.

또한 함수 선언문으로 함수를 정의하면 사용하기에 쉽지만 
대규모 애플리케이션을 개발하는 경우 인터프리터가 너무 많은 코드를 
변수 객체(VO)에 저장하므로 애플리케이션의 응답속도는 현저히 떨어질 수 있으므로 
주의해야 할 필요가 있다.
*/